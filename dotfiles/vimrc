" ##############################################################################
" ################################  Vim options  ############################### {{{
" ##############################################################################

set backspace=indent,eol,start
set diffopt+=vertical
set expandtab
set exrc
set foldcolumn=1
set foldmethod=manual
set formatoptions=cq
set hidden
set hlsearch
set ignorecase
set langmap=ЙQ,ЦW,УE,КR,ЕT,НY,ГU,ШI,ЩO,ЗP,Х[,Ъ],ФA,ЫS,ВD,АF,ПG,РH,ОJ,ЛK,ДL,Ж\\;,Э',ЯZ,ЧX,СC,МV,ИB,ТN,ЬM,Б\\,,Ю.,йq,цw,уe,кr,еt,нy,гu,шi,щo,зp,х[,ъ],фa,ыs,вd,аf,пg,рh,оj,лk,дl,ж\\;,э',яz,чx,сc,мv,иb,тn,ьm,б\\,,ю.,"@,№#,;$,:^,?&
set lazyredraw
set noautoindent
set nocompatible
set noesckeys
set nosmartindent
set number
set relativenumber
set ruler
set runtimepath+=~/.vim/bundle/Vundle.vim/
set secure
set shiftwidth=4
set showcmd
set softtabstop=4
set splitright
set t_ut=
set tabstop=4
set ttimeoutlen=0
set wildmenu
set shell=/bin/bash\ -O\ globstar
set foldmethod=marker
set completeopt=popup,menuone
set clipboard=exclude:cons\|linux

" Konsole does not seem to support Xterm escape sequences for changing cursor shape - disable it
set t_SH=

" Terminator seems to have trouble with these
set t_TI=
set t_TE=

highlight ExtraWhitespace ctermbg=darkgreen
highlight Terminal guifg=#c0c0c0 guibg=#000040 ctermfg=gray ctermbg=black
match ExtraWhitespace /\s\+$/
syntax enable

" ############################################################################## }}}
" ##############################  Plugin settings  ############################# {{{
" ##############################################################################

" C++11 syntax workaround
let c_no_curly_error=1

" Netrw settings
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro'
let g:netrw_keepdir = 0
let g:netrw_list_hide = ".*.swp"
let g:netrw_preview = 1 " Vertical preview window

" YouCompleteMe settings
let g:ycm_always_populate_location_list = 1
let g:ycm_confirm_extra_conf = 0
let g:ycm_global_ycm_extra_conf = expand('~/git/ovandriyanov/util/kernel_ycm_extra_conf.py')
let g:ycm_clangd_args=['--header-insertion=never']
let g:ycm_auto_hover=''
let g:ycm_max_diagnostics_to_display = 10
let g:ycm_add_preview_to_completeopt = 0
" let g:ycm_autoclose_preview_window_after_insertion = 1

" AutoPairs settings
let g:AutoPairsMapCR = 0
let g:AutoPairsMultilineClose = 0
let g:AutoPairsShortcutFastWrap = '<C-e>'
let g:AutoPairsShortcutJump = '<C-n>'
let g:AutoPairsShortcutToggle = '<C-p><C-p>'

" NERDTree settings
let g:loaded_netrwPlugin = 1
" let g:NERDTreeChDirMode = 3

" My settings
let g:olan_path_aliases_file = expand('~/.vim/path_aliases')

" ############################################################################## }}}
" ##############################  Custom commands  ############################# {{{
" ##############################################################################

command! Vrc exe 'edit' resolve(expand('~/.vimrc'))
command! TVrc tabnew | exe 'edit' resolve(expand('~/.vimrc'))
command! VVrc vsplit | exe 'edit' resolve(expand('~/.vimrc'))
command! SVrc split | exe 'edit' resolve(expand('~/.vimrc'))
command! Explore e .
command! SExplore split | e .
command! Ve vsplit | e .
command! StripTrailingWhitespace %s/\s\+$//e
command! -count=1 PadDown call Pad(<count>)
command! -count=1 PadUp call Pad(-<count>)
command! -bang DHidden call DeleteHiddenBuffers('<bang>')
command! -nargs=1 Yank call Yank('<args>')
command! -nargs=1 -complete=customlist,CompleteFileAliases C call OpenFileByAlias('<args>', '')
command! -nargs=1 -complete=customlist,CompleteFileAliases Sc call OpenFileByAlias('<args>', 'split')
command! -nargs=1 -complete=customlist,CompleteFileAliases Vc call OpenFileByAlias('<args>', 'vsplit')
command! -nargs=1 -complete=customlist,CompleteFileAliases Tc call OpenFileByAlias('<args>', 'tabnew')
command! TTerminal tabnew | terminal ++curwin
command! VTerminal vertical terminal
command! STerminal terminal
command! CTerminal terminal ++curwin
command! MTerminal split | resize 10 | set winfixheight | terminal ++curwin
command! -bang -range -nargs=1 -complete=shellcmd Xargs call Xargs('<args>', '<bang>' == '!')
command! -range Aopen call Aopen(<line1>, <line2>, 0)
command! -range AopenCurrent call Aopen(<line1>, <line2>, 1)
command! Scratch new | set bt=nofile
command! VScratch vnew | set bt=nofile
command! TScratch tabnew | set bt=nofile
command! -range=% Cgetbuffer call Cbuffer('cgetbuffer', <line1>, <line2>)
command! -range=% Cbuffer call Cbuffer('cbuffer', <line1>, <line2>)
command! Arel Yank !arel %
command! Include call Yank("!printf '\\#include <\\%s>\n\n' `arel %`")

" ############################################################################## }}}
" ##############################  Custom mappings  ############################# {{{
" ##############################################################################

" QtCreator-like bindings
nnoremap            <F2>            :YcmCompleter GoTo <cr>
nnoremap            <S-F2>          :YcmCompleter GoToDeclaration <cr>
nnoremap            <F4>            :silent! A <cr>
nnoremap            <F6>            :vsplit <cr>:YcmCompleter GoTo <cr>
nnoremap            <F8>            :silent! AV <cr>

" YouCompleteMe
nnoremap            <Tab><Tab>      :YcmCompleter GoTo<Cr>
nnoremap            <Tab>t          :YcmCompleter GetType<Cr>
nnoremap            <Tab>gt         :YcmCompleter GoToType<Cr>
nnoremap            <Tab>gi         :YcmCompleter GoToImplementation<Cr>
nnoremap            <Tab>x          :YcmCompleter FixIt<Cr>
nnoremap            <Tab>r          :YcmCompleter RefactorRename
nnoremap            <Tab>h          :YcmCompleter GetDoc<Cr>
nnoremap            <Tab>f          :YcmCompleter Format<Cr>

" NERDTree
nnoremap <expr>     <Cr>            NerdTreeFindExpr()

" Highlight word under cursor
nnoremap            <space>         :set hls \| call setreg('/', '\<' . expand('<cword>') . '\>')<Cr>
vnoremap            <space>         "zy:set hls \| call setreg('/', getreg('z'))<Cr>
vnoremap            \<space>        "zy:set hls \| call setreg('/', '\<' . getreg('z') . '\>')<Cr>

" Visual mode search
vnoremap            *               "zy/\V<c-r>=escape(getreg('z'), '/')<cr><cr>
vnoremap            #               "zy`<?\V<c-r>=escape(getreg('z'), '/')<cr><cr>
vnoremap            <Leader>*       "zy/\V\<<c-r>=escape(getreg('z'), '/')<cr>\><cr>
vnoremap            <leader>#       "zy`<?\V\<<c-r>=escape(getreg('z'), '/')<cr>\><cr>

" Command line register escaping
cnoremap            <c-r>\"         <c-r>=escape(getreg('"'), '/')<cr>
cnoremap            <c-r>\+         <c-r>=escape(getreg('+'), '/')<cr>

" Padding
nnoremap            <silent>        <Plug>PadDown :<c-U>call Pad(v:count1)<cr>:call repeat#set("\<Plug>PadDown")<cr>
nnoremap            <silent>        <Plug>PadUp :<c-U>call Pad(-v:count1)<cr>:call repeat#set("\<Plug>PadUp")<cr>
nnoremap            <C-p>j          <Plug>PadDown
nnoremap            <C-p>k          <Plug>PadUp
nnoremap            <silent>        <Plug>BreakAndPadComma :<c-U>call BreakAndPad(',', v:count1)<cr>:call repeat#set("\<Plug>BreakAndPadComma")<cr>
nmap                <C-p>,          <Plug>BreakAndPadComma

" Error navigation
nnoremap            <Right>          :cn<cr>
nnoremap            <Left>           :cp<cr>

" Buffer switching
nnoremap            <C-Right>       :bn<cr>
nnoremap            <C-Left>        :bp<cr>

" File navigation
nnoremap            <c-w>f          :call FindFileReuseWindow(0)<cr>
" TODO: implement
nnoremap            <c-w>F          :vertical wincmd F<cr>

vnoremap            <c-w>f          :call FindFileReuseWindow(1)<cr>
" TODO: implement
" vnoremap <c-w>F :<c-u>vertical wincmd F<cr>

" Jumping around
nnoremap            <C-F><C-O>      :silent call JumpToPrevFile()<Cr><C-g>
nnoremap            <C-F><C-I>      :silent call JumpToNextFile()<Cr><C-g>
nnoremap            <C-K>           :<C-U>call JumpOffset(-v:count1)<Cr>
nnoremap            <C-J>           :<C-U>call JumpOffset(+v:count1)<Cr>
nnoremap            [E              :lfirst<Cr>
nnoremap            [e              :lbefore<Cr>
nnoremap            ]e              :lafter<Cr>
nnoremap            ]E              :llast<Cr>
nnoremap            (               [(
nnoremap            )               ])

" Inserting
inoremap <expr> <CR> MapCarriageReturn()

" Commenting
nnoremap <C-_>iw "zciw/* <C-R>z */<Esc>bb
nnoremap <C-_>iW "zciw/* <C-R>z */<Esc>bB
vnoremap <C-_>   "zc/* <C-R>z */<Esc>gvo<Esc>W

" Scratch window
nnoremap <C-W>S :Scratch<Cr>

" URL opening (_G_o _B_rowser)
nnoremap gb :silent !xopen <cfile><Cr>
vnoremap gb "zy:silent execute '!xopen' shellescape(getreg('z'))<Cr>

" Opening man pages all of a sudden drives me crazy
nnoremap K k

" Arithmetic evaluation
vnoremap <Cr> c<C-r>=<C-r>"<Cr><Esc>

" Debugging
nnoremap <C-b> :call Break()<Cr>

" Should probably get rid of these...
nnoremap <F5>       :highlight ExtraWhitespace ctermbg=darkgreen <CR>
nnoremap <S-F5>     :highlight ExtraWhitespace NONE <CR>

" Scrolling
nnoremap <Down> 1<C-d>
nnoremap <Up>   1<C-u>

" Specal mappings for sequences generated by a terminal emulator {{{
"   HJKL window navigation
nnoremap <C-^>a<C-^>h <C-w>h
tnoremap <C-^>a<C-^>h <C-^>h
nnoremap <C-^>a<C-^>j <C-w>j
tnoremap <C-^>a<C-^>j <C-^>j
nnoremap <C-^>a<C-^>k <C-w>k
tnoremap <C-^>a<C-^>k <C-^>k
nnoremap <C-^>a<C-^>l <C-w>l
tnoremap <C-^>a<C-^>l <C-^>l

"   Buffer switching
nnoremap <C-^>as<C-^>j :bn<cr>
tnoremap <C-^>as<C-^>j <C-^>:bn<cr>
nnoremap <C-^>as<C-^>k :bp<cr>
tnoremap <C-^>as<C-^>k <C-^>:bp<cr>

"   Tab switching
nnoremap <C-^>as<C-^>h gT
tnoremap <C-^>as<C-^>h <C-^>gT
nnoremap <C-^>as<C-^>l gt
tnoremap <C-^>as<C-^>l <C-^>gt

"   Closing and opening windows
nnoremap <C-^>a<C-^>t :terminal<Cr>
nnoremap <C-^>a<C-^>n :new<Cr>
nnoremap <C-^>a<C-^>q :q<Cr>
tnoremap <C-^>a<C-^>q <C-^>:q<Cr>
nnoremap <C-^>a<C-^>w :bd<Cr>
tnoremap <C-^>a<C-^>w <C-^>:bd<Cr>
nnoremap <C-^>a<C-^>d :bd!<Cr>
tnoremap <C-^>a<C-^>d <C-^>:bd!<Cr>
nnoremap <C-^>a<C-^>o :only<Cr>
tnoremap <C-^>a<C-^>o <C-^>:only<Cr>
nnoremap <C-^>as<C-^>o :call ForceOnly()<Cr>
tnoremap <C-^>as<C-^>o <C-^>:call ForceOnly()<Cr>

"   To tell apart CTRL+I and Tab
nnoremap <C-^>c<C-^>i <C-i>
" }}}

" ############################################################################## }}}
" ############################  Automatic commands  ############################ {{{
" ##############################################################################

augroup vimrc
    " Clear all autocommands within augroup 'vimrc'
    autocmd!

    " Do not clear clipboard on exit
    autocmd VimLeave *                  call system("xsel -ib", getreg('+'))

    " Highlight extra whitespace
    autocmd WinNew *                    highlight ExtraWhitespace ctermbg=darkgreen
    autocmd WinNew *                    match ExtraWhitespace /\s\+$/

    " Set libstdc++ source files options
    autocmd BufRead,BufNewFile /usr/include/c++/*,/usr/include/x86_64-linux-gnu/c++/*,/usr/include/linux/* call SetLibStdCppOptions()

    autocmd BufWinEnter /* call ChdirToParentDir(expand('<amatch>'))

	autocmd BufWinEnter *.go setlocal noet

    autocmd TerminalOpen * set termwinkey=<C-^>
augroup END

" ############################################################################## }}}
" ##############################  Custom functions  ############################ {{{
" ##############################################################################

function! ChdirToParentDir(file)
    let l:newbufnr = bufnr(a:file)
    if getbufvar(l:newbufnr, '&buftype') != '' || bufnr() != l:newbufnr
        return
    endif

    let l:parent = fnamemodify(a:file, ':p:h')
    if len(l:parent) > 0
        execute 'lcd' l:parent
    endif
endfunction

function! SetLibStdCppOptions()
    setlocal ft=cpp
    setlocal tabstop=8
endfunction

function! Pad(count)
    let l:x = a:count
    " sleep 1
    let l:pad_to = col('.')
    while l:x != 0
        if l:x > 0
            exe 'normal j^'
            let l:x = l:x - 1
        elseif l:x < 0
            exe 'normal k^'
            let l:x = l:x + 1
        endif

        let l:pad_from = col('.')
        let l:diff = abs(l:pad_to - l:pad_from)
        if l:pad_from < l:pad_to
            exe 'normal ' . l:diff . 'i '
        elseif l:diff > 0
            exe 'normal ' . l:diff . 'X'
        endif
        call cursor(line('.'), l:pad_to)
    endwhile
endfunction

function! GetCurrentChar()
    return matchstr(getline('.'), '\%' . col('.') . 'c.')
endfunction

function! BreakAndPad(char, count)
    let l:i = 0
    while l:i < a:count
        let l:line = line('.')
        let l:col = col('.')
        exe 'normal f' . a:char
        if GetCurrentChar() != a:char
            return
        endif
        exe "normal a\n"
        call cursor(l:line, l:col)
        call Pad(1)
        let l:i = l:i + 1
    endwhile
endfunction

function! DeleteHiddenBuffers(bang)
    let tpbl=[]
    call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
    for buf in filter(range(1, bufnr('$')), 'bufloaded(v:val) && index(tpbl, v:val)==-1')
        silent execute 'silent bdelete' . a:bang buf
    endfor
endfunction

function! Yank(args)
    if len(a:args) > 1 && a:args[1] == ' '
        let l:reg = a:args[0]
        let l:yanktext = a:args[2 + match(a:args[2:], '[^ ]'):]
    else
        let l:reg = '"'
        let l:yanktext = a:args
    endif

    if l:yanktext[0] == '!'
        let l:cmdline = l:yanktext[1:]
        let l:result = system(l:cmdline)
        if v:shell_error != 0
            echoerr l:result
            return
        endif
        let l:rbound = l:result[-1:] == "\n" ? -2 : -1
        let l:yanktext = l:result[:l:rbound]
    endif

    exe 'let @' . l:reg . ' = "' . escape(expandcmd(l:yanktext), '"') . '"'
endfunction

function! IsTerminalWindow(winnr)
    let l:bufnr = winbufnr(a:winnr)
    let l:buftype = getbufvar(l:bufnr, '&buftype')
    return l:buftype == 'terminal'
endfunction

function! IsNerdTreeWindow(winnr)
    let l:bufnr = winbufnr(a:winnr)
    let l:filetype = getbufvar(l:bufnr, '&filetype')
    return l:filetype == 'nerdtree'
endfunction

function! OpenOrReuseWindow()
    " TODO: netrw windows not handled very well
    let l:curwin = winnr()
    let l:curtab = tabpagenr()
    let l:wincnt = tabpagewinnr(l:curtab, '$')
    let l:termcnt = 0
    let l:nerdtreecnt = 0

    for l:wnum in range(1, l:wincnt)
        if IsTerminalWindow(l:wnum)
            let l:termcnt += 1
        endif
        if IsNerdTreeWindow(l:wnum)
            let l:nerdtreecnt += 1
        endif
    endfor

    let l:reusable = l:wincnt
    let l:reusable -= l:termcnt
    let l:reusable -= IsTerminalWindow(l:curwin) ? 0 : 1
    let l:reusable -= IsNerdTreeWindow(l:curwin) ? 0 : 1

    if l:reusable == 0
        exe 'vsplit'
        let l:newwin = winnr()
        call win_gotoid(win_getid(l:curwin))
        return l:newwin
    endif

    for l:wnum in range(1, l:wincnt)
        if l:wnum != l:curwin && !IsTerminalWindow(l:wnum) && !IsNerdTreeWindow(l:wnum)
            return l:wnum
        endif
    endfor
endfunction

function! FindFileReuseWindow(visual)
    if a:visual
        norm gv"zy
        let l:cfile = getreg('z')
    else
        let l:cfile = expand('<cfile>')
    endif

    let l:includeexpr = substitute(&l:includeexpr, 'v:fname', 'l:cfile', '')
    if len(l:includeexpr)
        execute 'let l:cfile = ' . l:includeexpr
    endif

    let l:searchpath = &l:path
    if empty(l:searchpath)
        let l:searchpath = &g:path
    endif
    let l:searchpath = '.,' . l:searchpath

    let l:path = findfile(l:cfile, l:searchpath)
    if empty(l:path)
        let l:path = finddir(l:cfile, l:searchpath)
        if empty(l:path)
            echomsg "Can't find file " . l:cfile . " in path"
            return
        endif
    endif
    echom 'Found file or dir: ' . l:path

    let l:oldwinnr = winnr()
    let l:newwinnr = OpenOrReuseWindow()
    if getcwd(l:oldwinnr) !=# getcwd(l:newwinnr)
        let l:path = fnamemodify(l:path, ':p')
    endif

    call win_gotoid(win_getid(l:newwinnr))
    exe 'edit' l:path
endfunction

function! JumpToPrevFile()
    let [l:jumps, l:curjump] = getjumplist()
    let l:jumps = l:jumps[:l:curjump]
    call reverse(l:jumps)

    let l:i = l:curjump == len(l:jumps)
    for l:j in l:jumps
        if l:j['bufnr'] != bufnr()
            execute 'normal' l:i . "\<C-O>"
            return
        endif
        let l:i += 1
    endfor
    echo 'Already at oldest file'
endfunction

function! JumpToNextFile()
    let [l:jumps, l:curjump] = getjumplist()
    let l:jumps = l:jumps[l:curjump:]

    let l:i = 0
    for l:j in l:jumps
        if l:j['bufnr'] != bufnr()
            for l:jj in l:jumps[l:i + 1:]
                if l:jj['bufnr'] != l:j['bufnr']
                    break
                endif
                let l:i += 1
            endfor

            execute 'normal' l:i . "\<C-I>"
            return
        endif
        let l:i += 1
    endfor
    echo 'Already at newest file'
endfunction

function! LoadPathAliases()
    if exists('g:olan_path_aliases') && exists('g:olan_root_dirs')
        return
    endif

    try
        let g:olan_path_aliases = {}
        let g:olan_root_dirs = []
        for l:line in readfile(g:olan_path_aliases_file)
            let l:items = l:line->split()
            for l:alias in l:items[2:]
                let g:olan_path_aliases[tolower(l:alias)] = {'path': l:items[0], 'name': l:items[2]}
            endfor
            if l:items[1] == 'root'
                call add(g:olan_root_dirs, expand(l:items[0]))
            endif
        endfor
    catch /Can't open file/
        return
    endtry
endfunction

function! OpenFileByAlias(alias, window_splitter)
    call LoadPathAliases()

    let l:value = get(g:olan_path_aliases, tolower(a:alias))
    if type(l:value) == type(0) && !l:value
        echom 'Unknown alias: ' . a:alias
        return
    endif

    let l:path = expand(l:value['path'])

    if !isdirectory(l:path) && !filereadable(l:path)
        echom 'Cannot open ' . l:path
        return
    end

    if len(a:window_splitter) > 0
        execute a:window_splitter
    endif
    execute 'edit' l:path
endfunction

function! CompleteFileAliases(arglead, ...)
    call LoadPathAliases()

    let l:candidates = {}
    let l:Chop = len(a:arglead) ? {str -> str[:len(a:arglead) - 1]} : {str -> ''}

    for [l:alias, l:value] in items(g:olan_path_aliases)
        if l:Chop(l:alias) ==? a:arglead
            let l:name = l:value['name']
            let l:oldalias = get(l:candidates, l:name, 0)
            if type(l:oldalias) == type(0) || l:alias < l:oldalias
                let l:candidates[l:name] = l:alias
            endif
        endif
    endfor

    return map(
    \   sort(
    \       items(l:candidates),
    \       {l, r -> l[1] < r[1] ? -1 : l[1] > r[1]}
    \   ),
    \   'v:val[0]'
    \)
endfunction

function! Xargs(args, substitute)
    norm gv"zy
    let l:result = system('xargs --delimiter "\n" ' . a:args, getreg('z'))
    let l:exit_status = v:shell_error

    if l:exit_status != 0
        echoerr l:result
        return
    endif

    if a:substitute
        let l:rbound = l:result[-1:] == "\n" ? -2 : -1
        execute 'normal' "gv\"=l:result[:" . l:rbound . "]\<CR>p"
    endif
endfunction

function! JumpOffset(offset)
    let l:curpos = getcurpos()[1]
    let l:targetline = l:curpos + a:offset
    execute 'normal ' . l:targetline . 'G'
endfunction

function! Aopen(line1, line2, current)
    silent execute '!aopen %' a:line1 . '-' . a:line2 a:current ? '-c' : ''
endfunction

function! Arel(filename) abort
    let l:output = system('arel ' . shellescape(a:filename))
    let l:exit_status = v:shell_error
    if l:exit_status != 0
        throw 'arel: ' . l:output
    endif
    return l:output[:-2]
endfunction

function! Tapi_FillQuickfixWindow(buffer, logfile)
    execute 'cgetfile' a:logfile
    call system('rm -f ' . a:logfile)
endfunction

function! Tapi_Chdir(buffer, pwd)
    execute 'lcd' a:pwd
endfunction

function! MapCarriageReturn()
    let l:curcol = col('.')
    let l:curoffset = l:curcol - 1
    let l:line = getline('.')
    let l:prevchar = l:line[l:curoffset - 1]
    let l:curchar = l:line[l:curoffset]
    let l:eol = l:curcol - 1 == strlen(l:line)
    let l:almosteol = l:curcol == strlen(l:line)
    if l:prevchar != '{' || !(l:eol || l:almosteol && l:curchar == '}')
        return "\<CR>"
    endif

    if match(l:line, '^\s*{}\?') >= 0
        let l:prevline = getline(line('.') - 1)
        let l:line = l:prevline . l:line
    endif

    let l:add_semicolon = 0
    if &filetype == 'cpp'
        let l:add_semicolon = CppShouldAddSemicolon(l:line)
    elseif &filetype == 'sql'
        let l:add_semicolon = SqlShouldAddSemicolon(l:line)
    endif

    let l:maybe_semicolon = ''
    let l:maybe_rbrace = l:curchar == '}' ? '' : '}'
    if l:add_semicolon
        let l:maybe_semicolon = '}' ? ';' : "\<C-O>a;"
    endif

    return "\<CR>" . l:maybe_rbrace . l:maybe_semicolon . "\<C-O>O"
endfunction

function! CppShouldAddSemicolon(line)
    let l:opt_ws = '\s*'
    let l:ws = '\s\+'
    let l:ident = '[a-zA-Z_][a-zA-Z0-9_]*'
    let l:opt_cv = '\(const\s\+\|volatile\s\+\)\?'

    let l:class_definition =        '^' . l:opt_ws . 'class'  . l:ws
    let l:struct_definition =       '^' . l:opt_ws . 'struct' . l:ws
    let l:variable_initialization =
        \ '^' . l:opt_ws . l:opt_cv . l:opt_cv
        \ . l:ident . l:ws . l:ident . l:opt_ws . '[={]'

    for l:pattern in [
        \ l:class_definition,
        \ l:struct_definition,
        \ l:variable_initialization,
        \ ]
        if match(a:line, l:pattern) >= 0
            return 1
        endif
    endfor
endfunction

function! SqlShouldAddSemicolon(line)
    return match(a:line, '^\s*\%(\$[a-zA-Z_][a-zA-Z0-9_]*\s*=\|return\s\+\)') >= 0
endfunction

function! Cbuffer(cmd, line1, line2)
    execute a:line1 . ',' . a:line2 . a:cmd
endfunction

function! Break()
    call term_sendkeys(winbufnr(1), "break " . expand("%:p") . ':' . line('.') . "\<Cr>")
endfunction

function! NerdTreeFindExpr()
    call LoadPathAliases()

    if &bt != ''
        return "\<Cr>"
    endif

    let l:curpath = expand('%:p')
    let l:root = expand('%:p:h')
    let l:maxlen = 0
    for l:path in g:olan_root_dirs
        let l:prefix = l:curpath[0:len(l:path) - 1]
        echom 'PREFIX: ' . l:prefix
        echom 'PATH: ' . l:path
        if l:prefix == l:path && l:maxlen < len(l:prefix)
            let l:root = l:path
            let l:maxlen = len(l:prefix)
        endif
    endfor
    return ":NERDTree " . l:root . "\<Cr>:NERDTreeFind " . l:curpath . "\<Cr>"
endfunction

function! ForceOnly()
    let l:curwinid = win_getid()
    let l:winnr = 1
    let l:todelete = ''
    while 1
        let l:id = win_getid(l:winnr)

        if l:id == 0
            break
        endif

        if l:id == l:curwinid
            let l:winnr += 1
            continue
        end

        let l:todelete = l:todelete . ' ' . winbufnr(l:winnr)
        let l:winnr += 1
    endwhile

    execute 'bdelete!' l:todelete
endfunction

" ############################################################################## }}}
" ################################  Vundle stuff  ############################## {{{
" ##############################################################################

filetype off
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'

Plugin 'jiangmiao/auto-pairs'
Plugin 'endel/vim-github-colorscheme'
Plugin 'google/vim-searchindex'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-surround'
Plugin 'vim-scripts/BufOnly.vim'
Plugin 'preservim/nerdtree'

if exists('g:devmode') && g:devmode
    " C/C++ stuff
    Plugin 'vim-scripts/Cpp11-Syntax-Support'   " Proper C++11 syntax highlighting
    Plugin 'Valloric/YouCompleteMe'
    Plugin 'mom0tomo/dotfiles'
    Plugin 'vim-scripts/git-time-lapse'
    Plugin 'vim-scripts/a.vim'                  " Quick switching between .h/.cpp
    Plugin 'tpope/vim-fugitive'
    Plugin 'vim-signify', {'pinned': 1}
    " Plugin 'vim-quarc', {'pinned': 1}
endif

call vundle#end()
filetype plugin indent on

colorscheme github

" ############################################################################## }}}
" ############################  Extra configuration  ########################### {{{
" ##############################################################################

let s:extra_conf_file = expand('~/.vim/extra.vim')
if filereadable(s:extra_conf_file)
    exe "source " . s:extra_conf_file
endif

" ############################################################################## }}}
