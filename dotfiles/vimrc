" ##############################################################################
" ################################  Vim options  ############################### {{{
" ##############################################################################

set nowrap
set backspace=indent,eol,start
set diffopt+=vertical
set expandtab
set exrc
set foldcolumn=0
set formatoptions=cq
set hidden
set hlsearch
set ignorecase
set langmap=ЙQ,ЦW,УE,КR,ЕT,НY,ГU,ШI,ЩO,ЗP,Х[,Ъ],ФA,ЫS,ВD,АF,ПG,РH,ОJ,ЛK,ДL,Ж\\;,Э',ЯZ
set langmap+=ЧX,СC,МV,ИB,ТN,ЬM,Б\\,,Ю.,йq,цw,уe,кr,еt,нy,гu,шi,щo,зp,х[,ъ],фa,ыs,вd
set langmap+=аf,пg,рh,оj,лk,дl,ж\\;,э',яz,чx,сc,мv,иb,тn,ьm,б\\,,ю.,"@,№#,;$,:^,?&
set lazyredraw
set noautoindent
set nocompatible
set noesckeys
set nosmartindent
set number
set relativenumber
set ruler
set runtimepath+=~/.vim/bundle/Vundle.vim/
set secure
set shiftwidth=4
set showcmd
set softtabstop=4
set splitright
set t_ut=
set tabstop=4
set ttimeoutlen=0
set wildmenu
set shell=/bin/bash\ -O\ globstar
set foldmethod=marker
set completeopt=popup,menuone
set clipboard=exclude:cons\|linux
set scrolloff=10

let s:grepfmt = '%f|%l col %c| %m'
if       &errorformat !~# '^' . s:grepfmt . ',.*'
    \ && &errorformat !~# ',' . s:grepfmt . ',.*'
    let &errorformat = s:grepfmt . ',' . &errorformat
endif

" Konsole does not seem to support Xterm escape sequences for changing cursor shape - disable it
set t_SH=

" Terminator seems to have trouble with these
set t_TI=
set t_TE=

highlight ExtraWhitespace ctermbg=darkgreen
highlight Terminal guifg=#c0c0c0 guibg=#000040 ctermfg=gray ctermbg=black
match ExtraWhitespace /\s\+$/
syntax enable

" ############################################################################## }}}
" ##############################  Plugin settings  ############################# {{{
" ##############################################################################

" C++11 syntax workaround
let c_no_curly_error=1

" Netrw settings
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro'
let g:netrw_keepdir = 0
let g:netrw_list_hide = ".*.swp"
let g:netrw_preview = 1 " Vertical preview window

" YouCompleteMe settings
let g:ycm_always_populate_location_list = 1
let g:ycm_confirm_extra_conf = 0
let g:ycm_global_ycm_extra_conf = expand('~/git/ovandriyanov/util/kernel_ycm_extra_conf.py')
let g:ycm_clangd_args=['--header-insertion=never']
let g:ycm_auto_hover=''
let g:ycm_max_diagnostics_to_display = 10
let g:ycm_add_preview_to_completeopt = 0
let g:ycm_key_invoke_completion = '<C-^>c<C-^><Space>'
" let g:ycm_autoclose_preview_window_after_insertion = 1

" AutoPairs settings
let g:AutoPairsMapCR = 0
let g:AutoPairsMultilineClose = 0
let g:AutoPairsShortcutFastWrap = '<C-e>'
let g:AutoPairsShortcutJump = '<C-n>'
let g:AutoPairsShortcutToggle = '<C-p><C-p>'

" NERDTree settings
let g:loaded_netrwPlugin = 1
let g:NERDTreeMapHelp = ''
let g:NERDTreeCustomOpenArgs = {'file': {'reuse': '', 'where': 'p'}, 'dir': {}}
let g:NERDTreeCascadeSingleChildDir=0
" let g:NERDTreeChDirMode = 3

" Fugitive settings
cnoreabbrev <expr> Gstatus ((getcmdtype() ==# ':' && getcmdline() ==# 'Gstatus') ? 'aboveleft Gstatus' : 'Gstatus')

" My settings
let g:olan_path_aliases_file = expand('~/.vim/path_aliases')

" ############################################################################## }}}
" ##############################  Custom commands  ############################# {{{
" ##############################################################################

command! Vrc exe 'edit' resolve(expand('~/.vimrc'))
command! TVrc tabnew | exe 'edit' resolve(expand('~/.vimrc'))
command! VVrc vsplit | exe 'edit' resolve(expand('~/.vimrc'))
command! SVrc split | exe 'edit' resolve(expand('~/.vimrc'))
command! Explore e .
command! SExplore split | e .
command! Ve vsplit | e .
command! StripTrailingWhitespace %s/\s\+$//e
command! -count=1 PadDown call Pad(<count>)
command! -count=1 PadUp call Pad(-<count>)
command! -bang DHidden call DeleteHiddenBuffers('<bang>')
command! -nargs=1 Yank call Yank('<args>')
command! -nargs=1 -complete=customlist,CompleteFileAliases C call OpenFileByAlias('<args>', '')
command! -nargs=1 -complete=customlist,CompleteFileAliases Sc call OpenFileByAlias('<args>', 'split')
command! -nargs=1 -complete=customlist,CompleteFileAliases Vc call OpenFileByAlias('<args>', 'vsplit')
command! -nargs=1 -complete=customlist,CompleteFileAliases Tc call OpenFileByAlias('<args>', 'tabnew')
command! TTerminal tabnew | terminal ++curwin
command! VTerminal vertical terminal
command! STerminal terminal
command! CTerminal terminal ++curwin
command! MTerminal split | resize 10 | set winfixheight | terminal ++curwin
command! -bang -range -nargs=1 -complete=shellcmd Xargs call Xargs('<args>', '<bang>' == '!')
command! -range Aopen call Aopen(<line1>, <line2>, 0)
command! -range AopenCurrent call Aopen(<line1>, <line2>, 1)
command! Scratch new | set bt=nofile
command! VScratch vnew | set bt=nofile
command! TScratch tabnew | set bt=nofile
command! -range=% Cgetbuffer call Cbuffer('cgetbuffer', <line1>, <line2>)
command! -range=% Cbuffer call Cbuffer('cbuffer', <line1>, <line2>)
command! Arel Yank !arel %
command! Include call Include()
command! Break call Break()

" ############################################################################## }}}
" ##############################  Custom mappings  ############################# {{{
" ##############################################################################

" QtCreator-like bindings {{{
nnoremap            <F2>            :YcmCompleter GoTo <cr>
nnoremap            <S-F2>          :YcmCompleter GoToDeclaration <cr>
nnoremap            <F4>            :silent! A <cr>
nnoremap            <F6>            :vsplit <cr>:YcmCompleter GoTo <cr>
nnoremap            <F8>            :silent! AV <cr>
" }}}

" YouCompleteMe {{{
nnoremap            <Tab>           <Nop>
nnoremap            <Tab><Space>    :call GoTo()<Cr>
nnoremap            <Tab>t          :YcmCompleter GetType<Cr>
nnoremap            <Tab>gt         :YcmCompleter GoToType<Cr>
nnoremap            <Tab>i          :call GoToImplementation()<Cr>
nnoremap            <Tab>x          :YcmCompleter FixIt<Cr>
nnoremap            <Tab>r          "zyiw:call RefactorRename('<C-r>z')<Left><Left>
nnoremap            <Tab>h          :YcmCompleter GetDoc<Cr>
nnoremap            <Tab>f          :YcmCompleter Format<Cr>
nnoremap            <Tab>u          :call GoToReferences()<Cr>
nnoremap            <Tab>d          :call Diags()<Cr>
" }}}

" NERDTree {{{
nnoremap <expr>     <Cr>            NerdTreeFindExpr()
" }}}

" Highlight word under cursor {{{
nnoremap            <space>         :set hls \| call setreg('/', '\<' . expand('<cword>') . '\>')<Cr>
vnoremap            <space>         "zy:set hls \| call setreg('/', getreg('z'))<Cr>
vnoremap            \<space>        "zy:set hls \| call setreg('/', '\<' . getreg('z') . '\>')<Cr>
" }}}

" Visual mode search {{{
vnoremap            *               "zy/\V<c-r>=escape(getreg('z'), '/')<cr><cr>
vnoremap            #               "zy`<?\V<c-r>=escape(getreg('z'), '/')<cr><cr>
vnoremap            <Leader>*       "zy/\V\<<c-r>=escape(getreg('z'), '/')<cr>\><cr>
vnoremap            <leader>#       "zy`<?\V\<<c-r>=escape(getreg('z'), '/')<cr>\><cr>
" }}}

" Command line register escaping {{{
cnoremap            <c-r>\"         <c-r>=escape(getreg('"'), '/')<cr>
cnoremap            <c-r>\+         <c-r>=escape(getreg('+'), '/')<cr>
" }}}

" Padding {{{
nnoremap            <silent>        <Plug>PadDown :<c-U>call Pad(v:count1)<cr>:call repeat#set("\<Plug>PadDown")<cr>
nnoremap            <silent>        <Plug>PadUp :<c-U>call Pad(-v:count1)<cr>:call repeat#set("\<Plug>PadUp")<cr>
nnoremap            <C-p>j          <Plug>PadDown
nnoremap            <C-p>k          <Plug>PadUp
nnoremap            <silent>        <Plug>BreakAndPadComma :<c-U>call BreakAndPad(',', v:count1)<cr>:call repeat#set("\<Plug>BreakAndPadComma")<cr>
nmap                <C-p>,          <Plug>BreakAndPadComma
" }}}

" Error navigation {{{
nnoremap            <Right>          :cn<cr>
nnoremap            <Left>           :cp<cr>
" }}}

" Buffer switching {{{
nnoremap            <C-Right>       :bn<cr>
nnoremap            <C-Left>        :bp<cr>
" }}}

" File navigation {{{
nnoremap            <c-w>f          :call FindFileReuseWindow(0)<cr>
" TODO: implement
nnoremap            <c-w>F          :vertical wincmd F<cr>
" }}}

vnoremap            <c-w>f          :call FindFileReuseWindow(1)<cr> {{{
" TODO: implement
" vnoremap <c-w>F :<c-u>vertical wincmd F<cr>
" }}}

" Jumping around {{{
nnoremap            <C-F><C-O>      :silent call JumpToPrevFile()<Cr><C-g>
nnoremap            <C-F><C-I>      :silent call JumpToNextFile()<Cr><C-g>
nnoremap            <C-F><Esc>      <Nop>
nnoremap            <C-F>           <Nop>
nnoremap <expr>     k               JumpOffsetExpr(-v:count1)
nnoremap <expr>     j               JumpOffsetExpr(+v:count1)
nnoremap            [E              :lfirst<Cr>
nnoremap            [e              :lbefore<Cr>
nnoremap            ]e              :lafter<Cr>
nnoremap            ]E              :llast<Cr>
nnoremap            (               [(
vnoremap            (               [(
nnoremap            )               ])
vnoremap            )               ])
" }}}

" Inserting {{{
inoremap <expr> <CR> MapCarriageReturn()
" }}}

" Formatting {{{
vnoremap <C-^>a<C-^>j :<C-u>call JsonFormat()<Cr>
" }}}

" Commenting {{{
nnoremap <C-_>iw "zciw/* <C-R>z */<Esc>bb
nnoremap <C-_>iW "zciw/* <C-R>z */<Esc>bB
vnoremap <C-_>   "zc/* <C-R>z */<Esc>gvo<Esc>W
" }}}

" Scratch window {{{
nnoremap <C-W>S :Scratch<Cr>
" }}}

" URL opening (_G_o _B_rowser) {{{
nnoremap gb :silent !xopen <cfile><Cr>
vnoremap gb "zy:silent execute '!xopen' shellescape(getreg('z'))<Cr>
" }}}

" Opening man pages all of a sudden drives me crazy {{{
nnoremap K k
" }}}

" Arithmetic evaluation {{{
vnoremap <Cr> c<C-r>=<C-r>"<Cr><Esc>
" }}}

" Debugging {{{
nnoremap <C-b> :call Break()<Cr>
" }}}

" Should probably get rid of these... {{{
nnoremap <F5>       :highlight ExtraWhitespace ctermbg=darkgreen <CR>
nnoremap <S-F5>     :highlight ExtraWhitespace NONE <CR>
" }}}

" Scrolling {{{
nnoremap <Down> 1<C-d>
nnoremap <Up>   1<C-u>
" }}}

" Specal mappings for sequences generated by a terminal emulator {{{
"   Window navigation {{{
nnoremap <C-^>a<C-^>h <C-w>h
tnoremap <C-^>a<C-^>h <C-^>h
nnoremap <C-^>a<C-^>j <C-w>j
tnoremap <C-^>a<C-^>j <C-^>j
nnoremap <C-^>a<C-^>k <C-w>k
tnoremap <C-^>a<C-^>k <C-^>k
nnoremap <C-^>a<C-^>l <C-w>l
tnoremap <C-^>a<C-^>l <C-^>l
nnoremap <C-^>a<C-^>p <C-w>p
tnoremap <C-^>a<C-^>p <C-^>p
" }}}

"   Align windows with HJKL {{{
nnoremap <C-^>as<C-^>h :call Align('H')<Cr>
nnoremap <C-^>as<C-^>j :call Align('J')<Cr>
nnoremap <C-^>as<C-^>k :call Align('K')<Cr>
nnoremap <C-^>as<C-^>l :call Align('L')<Cr>
tnoremap <C-^>as<C-^>h <C-^>:call Align('H')<Cr>
tnoremap <C-^>as<C-^>j <C-^>:call Align('J')<Cr>
tnoremap <C-^>as<C-^>k <C-^>:call Align('K')<Cr>
tnoremap <C-^>as<C-^>l <C-^>:call Align('L')<Cr>
" }}}

"   Tab switching {{{
nnoremap <C-^>ac<C-^>h gT
tnoremap <C-^>ac<C-^>h <C-^>gT
nnoremap <C-^>ac<C-^>l gt
tnoremap <C-^>ac<C-^>l <C-^>gt
nnoremap <C-^>as<C-^>t <C-w>s<C-w>T:tabmove -1<Cr>
tnoremap <C-^>as<C-^>t <C-^>s<C-^>T<C-^>:tabmove -1<Cr>
nnoremap <C-^>as<C-^>w <C-w>T:tabmove -1<Cr>
tnoremap <C-^>as<C-^>w <C-^>T<C-^>:tabmove -1<Cr>
" }}}

"   Tab shifting {{{
nnoremap <C-^>acs<C-^>h :tabmove -1<Cr>
tnoremap <C-^>acs<C-^>h <C-^>:tabmove -1<Cr>
nnoremap <C-^>acs<C-^>l :tabmove +1<Cr>
tnoremap <C-^>acs<C-^>l <C-^>:tabmove +1<Cr>
" }}}

"   Closing and opening windows {{{
nnoremap <C-^>a<C-^>t :terminal<Cr><C-^>:set nowinfixwidth<Cr>
tnoremap <C-^>a<C-^>t <C-^>:terminal<Cr><C-^>:set nowinfixwidth<Cr>
nnoremap <C-^>a<C-^>n :exec &bt ==# 'terminal' ? 'rightbelow new' : 'new'<Cr>
tnoremap <C-^>a<C-^>n <C-^>:rightbelow new<Cr>
nnoremap <C-^>a<C-^>b :tabnew<Cr>
tnoremap <C-^>a<C-^>b <C-^>:tabnew<Cr>
nnoremap <C-^>a<C-^>q :q<Cr>
tnoremap <C-^>a<C-^>q <C-^>:q<Cr>
nnoremap <C-^>as<C-^>q :tabclose<Cr>
tnoremap <C-^>as<C-^>q <C-^>:tabclose<Cr>
nnoremap <C-^>a<C-^>w :w<Cr>
nnoremap <C-^>a<C-^>x :wq<Cr>
inoremap <C-^>a<C-^>x <Esc>:wq<Cr>
nnoremap <C-^>a<C-^>d :bd!<Cr>
tnoremap <C-^>a<C-^>d <C-^>:bd!<Cr>
nnoremap <C-^>as<C-^>d :call DropTab()<Cr>
tnoremap <C-^>as<C-^>d <C-^>:call DropTab()<Cr>
nnoremap <C-^>a<C-^>o :call Only()<Cr>
tnoremap <C-^>a<C-^>o <C-^>:call Only()<Cr>
nnoremap <C-^>as<C-^>o :only<Cr>
tnoremap <C-^>as<C-^>o <C-^>:only<Cr>
nnoremap <C-^>a<C-^>v <C-w>v
nnoremap <C-^>a<C-^>s <C-w>s
nnoremap <C-^>ac<C-^>d :DHidden<Cr>
tnoremap <C-^>ac<C-^>d <C-^>:DHidden<Cr>
nnoremap <C-^>acs<C-^>d :DHidden!<Cr>
tnoremap <C-^>acs<C-^>d <C-^>:DHidden!<Cr>
" }}}

" Mode switching in terminal window {{{
tnoremap <C-^>as<C-^>n <C-^>N
nnoremap <C-^>as<C-^>n i
" }}}

" Toggle termwinsize with alt+w
tnoremap <C-^>a<C-^>w <C-^>:call ToggleTermwinsize()<Cr>

" Registers {{{
tnoremap <C-^>a<C-^>r <C-^>"
inoremap <C-^>a<C-^>r <C-r>
cnoremap <C-^>a<C-^>r <C-r>
" }}}

"   To tell apart CTRL+I and Tab {{{
nnoremap <C-^>c<C-^>i <C-i>
" }}}

"   Enter command mode from terminal mode {{{
tnoremap <C-^>a<C-^><Esc> <C-^>:
nnoremap <C-^>a<C-^><Esc> <Esc>
inoremap <C-^>a<C-^><Esc> <Esc>
vnoremap <C-^>a<C-^><Esc> <Esc>
cnoremap <C-^>a<C-^><Esc> <C-c>
" }}}

"   Text highlighting {{{
nnoremap <C-^>a<C-^><Space> :nohlsearch<Cr>
inoremap <C-^>a<C-^><Space> <C-o>:nohlsearch<Cr>
tnoremap <C-^>a<C-^><Space> <C-^>:nohlsearch<Cr>
"    }}}

"   Jumping around {{{
nnoremap <C-^>a<C-^>u :call Up()<Cr>
nnoremap <C-^>as<C-^>u 100[{
vnoremap <C-^>a<C-^>u :<C-D>call Up()<Cr>
vnoremap <C-^>as<C-^>u 100[{
nnoremap <C-^>a<C-^>c :C 
tnoremap <C-^>a<C-^>c <C-^>:C 
"    }}}

"   Grep {{{
nnoremap <expr> <C-^>a<C-^>g GrepExpr(0)
nnoremap <expr> <C-^>as<C-^>g GrepExpr(1)
nnoremap <Tab><Tab> :call Grep('\<' . expand('<cword>') . '\>', 0)<Cr>
vnoremap <Tab> "zy:call Grep(getreg('z'), 0)<Cr>
"   }}}

"   SQL {{{
nnoremap <C-^>c<C-^><Space> :call CtrlSpace()<Cr>
vnoremap <C-^>c<C-^><Space> :<C-U>DBExecVisualSQL<Cr>
"   }}}

"   Sorting text {{{
vnoremap <C-^>a<C-^>s :sort<Cr>
"   }}}

"    Settings {{{
nnoremap <C-^>a<C-^>w :let &wrap=!&wrap<Cr>
"    }}}

" }}}

" ############################################################################## }}}
" ############################  Automatic commands  ############################ {{{
" ##############################################################################

augroup vimrc
    " Clear all autocommands within augroup 'vimrc'
    autocmd!

    " Do not clear clipboard on exit
    autocmd VimLeave *                  call system("xsel -ib", getreg('+'))

    " Highlight extra whitespace
    autocmd WinNew *                    highlight ExtraWhitespace ctermbg=darkgreen
    autocmd WinNew *                    match ExtraWhitespace /\s\+$/

    " Set libstdc++ source files options
    autocmd BufRead,BufNewFile /usr/include/c++/*,/usr/include/x86_64-linux-gnu/c++/*,/usr/include/linux/* call SetLibStdCppOptions()

    autocmd BufWinEnter /* call ChdirToParentDir(expand('<amatch>'))

	autocmd BufWinEnter *.go setlocal noet

    autocmd FileType nerdtree set relativenumber
    autocmd FileType nerdtree nnoremap <buffer> <nowait> <C-F> :NERDTreeFind **/
    autocmd FileType nerdtree nnoremap <buffer>          <C-^>a<C-^>t  :call OpenTerminalFromNerdTree(0)<Cr>
    autocmd FileType nerdtree nnoremap <buffer>          <C-^>as<C-^>t :call OpenTerminalFromNerdTree(1)<Cr>
    autocmd FileType nerdtree nnoremap <buffer>          <C-c> :call setreg('"', g:NERDTreeFileNode.GetSelected().path.str())<Cr>
    autocmd FileType nerdtree nunmap <buffer> :call
    autocmd FileType nerdtree nunmap <buffer> CD
    autocmd FileType qf setlocal foldmethod=manual
    autocmd FileType qf call ReloadQuickFix()
    autocmd User NERDTreeNewRoot execute 'lcd' g:NERDTree.ForCurrentBuf().root.path.str()
    autocmd User NERDTreeInit execute 'lcd' g:NERDTree.ForCurrentBuf().root.path.str()
    autocmd BufEnter * call NerdTreeSync(0, 'BufEnter', expand('<amatch>'))
    autocmd DirChanged * call NerdTreeSync(0, 'DirChanged', expand('<amatch>'))
    autocmd BufWritePost * call NerdTreeSync(0, 'BufWritePost', expand('<amatch>'))
    autocmd BufWritePre *.go :YcmCompleter Format
    autocmd BufWinEnter * call NerdTreeSync(1, 'BufWinEnter', expand('<amatch>'))
    autocmd FileType * call NerdTreeSync(1, 'FileType', expand('<amatch>'))
    autocmd TerminalOpen * call NerdTreeSync(1, 'TerminalOpen', expand('<amatch>'))
    autocmd TerminalOpen * setlocal scrolloff=0
    autocmd User OlanInitNtsync call NerdTreeSync(1, 'OlanInitNtsync', expand('<amatch>'))
    autocmd User YcmQuickFixOpened resize 10|autocmd! ycmquickfix WinLeave

    autocmd TerminalOpen * set termwinkey=<C-^>
    autocmd TerminalOpen * setlocal nowrap
    autocmd TerminalOpen * set wfw | setlocal termwinsize=0*5000

    execute 'autocmd BufWritePost' g:olan_path_aliases_file 'unlet! g:olan_path_aliases'

    autocmd QuickFixCmdPre * copen|execute 'lcd'  ProjectDir()
augroup END

" ############################################################################## }}}
" ##############################  Custom functions  ############################ {{{
" ##############################################################################

function! ChdirToParentDir(file) " {{{
    if &ft ==# 'qf'
        return
    endif
    if &ft ==# 'nerdtree'
        execute 'lcd' g:NERDTree.ForCurrentBuf().root.path.str()
        return
    endif
    let l:newbufnr = bufnr(a:file)
    if getbufvar(l:newbufnr, '&buftype') != '' || bufnr() != l:newbufnr
        return
    endif

    let l:parent = fnamemodify(a:file, ':p:h')
    if len(l:parent) > 0
        execute 'lcd' l:parent
    endif
endfunction " }}}

function! SetLibStdCppOptions() " {{{
    setlocal ft=cpp
    setlocal tabstop=8
endfunction " }}}

function! Pad(count) " {{{
    let l:x = a:count
    let l:pad_to = col('.')
    while l:x != 0
        if l:x > 0
            exe 'normal j^'
            let l:x = l:x - 1
        elseif l:x < 0
            exe 'normal k^'
            let l:x = l:x + 1
        endif

        let l:pad_from = col('.')
        let l:diff = abs(l:pad_to - l:pad_from)
        if l:pad_from < l:pad_to
            exe 'normal ' . l:diff . 'i '
        elseif l:diff > 0
            exe 'normal ' . l:diff . 'X'
        endif
        call cursor(line('.'), l:pad_to)
    endwhile
endfunction " }}}

function! GetCurrentChar() " {{{
    return matchstr(getline('.'), '\%' . col('.') . 'c.')
endfunction " }}}

function! BreakAndPad(char, count) " {{{
    let l:i = 0
    while l:i < a:count
        let l:line = line('.')
        let l:col = col('.')
        exe 'normal f' . a:char
        if GetCurrentChar() != a:char
            return
        endif
        exe "normal a\n"
        call cursor(l:line, l:col)
        call Pad(1)
        let l:i = l:i + 1
    endwhile
endfunction " }}}

function! DeleteHiddenBuffers(bang) " {{{
    let tpbl=[]
    call map(range(1, tabpagenr('$')), 'extend(tpbl, tabpagebuflist(v:val))')
    for buf in filter(range(1, bufnr('$')), 'bufloaded(v:val) && index(tpbl, v:val)==-1')
        silent execute 'silent bdelete' . a:bang buf
    endfor
endfunction " }}}

function! Yank(args) " {{{
    if len(a:args) > 1 && a:args[1] == ' '
        let l:reg = a:args[0]
        let l:yanktext = a:args[2 + match(a:args[2:], '[^ ]'):]
    else
        let l:reg = '"'
        let l:yanktext = a:args
    endif

    if l:yanktext[0] == '!'
        let l:cmdline = l:yanktext[1:]
        let l:result = system(l:cmdline)
        if v:shell_error != 0
            echoerr l:result
            return
        endif
        let l:rbound = l:result[-1:] == "\n" ? -2 : -1
        let l:yanktext = l:result[:l:rbound]
    endif

    exe 'let @' . l:reg . ' = "' . escape(expandcmd(l:yanktext), '"') . '"'
endfunction " }}}

function! IsTerminalWindow(winnr) " {{{
    let l:bufnr = winbufnr(a:winnr)
    let l:buftype = getbufvar(l:bufnr, '&buftype')
    return l:buftype == 'terminal'
endfunction " }}}

function! IsNerdTreeWindow(winnr) " {{{
    let l:bufnr = winbufnr(a:winnr)
    let l:filetype = getbufvar(l:bufnr, '&filetype')
    return l:filetype == 'nerdtree'
endfunction " }}}

function! OpenOrReuseWindow() " {{{
    let l:curwin = winnr()
    let l:curtab = tabpagenr()
    let l:wincnt = tabpagewinnr(l:curtab, '$')
    let l:termcnt = 0
    let l:nerdtreecnt = 0

    for l:wnum in range(1, l:wincnt)
        if IsTerminalWindow(l:wnum)
            let l:termcnt += 1
        elseif IsNerdTreeWindow(l:wnum)
            let l:nerdtreecnt += 1
        endif
    endfor

    let l:reusable = l:wincnt
    let l:reusable -= l:termcnt
    let l:reusable -= l:nerdtreecnt
    let l:reusable -= IsTerminalWindow(l:curwin) || IsNerdTreeWindow(l:curwin) ? 0 : 1

    if l:reusable == 0
        if getwinvar(l:curwin, '&bt') == 'terminal'
            let l:splitbelow = &splitbelow
            let &splitbelow = 1
            split
            let &splitbelow = l:splitbelow
        else
            vsplit
        endif

        let l:newwin = winnr()
        call win_gotoid(win_getid(l:curwin))
        return l:newwin
    endif

    for l:wnum in range(1, l:wincnt)
        if l:wnum != l:curwin && !IsTerminalWindow(l:wnum) && !IsNerdTreeWindow(l:wnum)
            return l:wnum
        endif
    endfor
endfunction " }}}

function! FindFileReuseWindow(visual) " {{{
    if a:visual
        norm gv"zy
        let l:cfile = getreg('z')
    else
        let l:cfile = expand('<cfile>')
    endif

    let l:includeexpr = substitute(&l:includeexpr, 'v:fname', 'l:cfile', '')
    if len(l:includeexpr)
        execute 'let l:cfile = ' . l:includeexpr
    endif

    let l:searchpath = &l:path
    if empty(l:searchpath)
        let l:searchpath = &g:path
    endif
    let l:searchpath = '.,' . l:searchpath

    let l:path = findfile(l:cfile, l:searchpath)
    if empty(l:path)
        let l:path = finddir(l:cfile, l:searchpath)
        if empty(l:path)
            echomsg "Can't find file " . l:cfile . " in path"
            return
        endif
    endif

    let l:oldwinnr = winnr()
    let l:newwinnr = OpenOrReuseWindow()
    if getcwd(l:oldwinnr) !=# getcwd(l:newwinnr)
        let l:path = fnamemodify(l:path, ':p')
    endif

    call win_gotoid(win_getid(l:newwinnr))
    exe 'edit' l:path
endfunction " }}}

function! JumpToPrevFile() " {{{
    let [l:jumps, l:curjump] = getjumplist()
    let l:jumps = l:jumps[:l:curjump]
    call reverse(l:jumps)

    let l:i = l:curjump == len(l:jumps)
    for l:j in l:jumps
        if l:j['bufnr'] != bufnr()
            execute 'normal' l:i . "\<C-O>"
            return
        endif
        let l:i += 1
    endfor
    echo 'Already at oldest file'
endfunction " }}}

function! JumpToNextFile() " {{{
    let [l:jumps, l:curjump] = getjumplist()
    let l:jumps = l:jumps[l:curjump:]

    let l:i = 0
    for l:j in l:jumps
        if l:j['bufnr'] != bufnr()
            for l:jj in l:jumps[l:i + 1:]
                if l:jj['bufnr'] != l:j['bufnr']
                    break
                endif
                let l:i += 1
            endfor

            execute 'normal' l:i . "\<C-I>"
            return
        endif
        let l:i += 1
    endfor
    echo 'Already at newest file'
endfunction " }}}

function! LoadPathAliases() " {{{
    if exists('g:olan_path_aliases') && exists('g:olan_root_dirs')
        return
    endif

    try
        let g:olan_path_aliases = {}
        let g:olan_root_dirs = []
        for l:line in readfile(g:olan_path_aliases_file)
            let l:items = l:line->split()
            for l:alias in l:items[2:]
                let g:olan_path_aliases[tolower(l:alias)] = {'path': l:items[0], 'name': l:items[2]}
            endfor
            if l:items[1] == 'root'
                call add(g:olan_root_dirs, expand(l:items[0]))
            endif
        endfor
    catch /Can't open file/
        return
    endtry
endfunction " }}}

function! OpenFileByAlias(alias, window_splitter) " {{{
    call LoadPathAliases()

    let l:value = get(g:olan_path_aliases, tolower(a:alias))
    if type(l:value) == type(0) && !l:value
        echom 'Unknown alias: ' . a:alias
        return
    endif

    let l:path = expand(l:value['path'])

    if !isdirectory(l:path) && !filereadable(l:path)
        echom 'Cannot open ' . l:path
        return
    end

    if len(a:window_splitter) > 0
        execute a:window_splitter
    endif

    if isdirectory(l:path)
        if has_key(b:, 'NERDTree') && winnr('$') == 1
            let l:curbuf = bufnr()
            new
            execute 'bdelete' l:curbuf
            let l:emptybuf = bufnr()
            execute 'NERDTree' l:path
            execute 'bdelete' l:emptybuf
        else
            execute 'NERDTree' l:path
        endif
    else
        execute 'edit' l:path
    endif
endfunction " }}}

function! CompleteFileAliases(arglead, ...) " {{{
    call LoadPathAliases()

    let l:candidates = {}
    let l:Chop = len(a:arglead) ? {str -> str[:len(a:arglead) - 1]} : {str -> ''}

    for [l:alias, l:value] in items(g:olan_path_aliases)
        if l:Chop(l:alias) ==? a:arglead
            let l:name = l:value['name']
            let l:oldalias = get(l:candidates, l:name, 0)
            if type(l:oldalias) == type(0) || l:alias < l:oldalias
                let l:candidates[l:name] = l:alias
            endif
        endif
    endfor

    return map(
    \   sort(
    \       items(l:candidates),
    \       {l, r -> l[1] < r[1] ? -1 : l[1] > r[1]}
    \   ),
    \   'v:val[0]'
    \)
endfunction " }}}

function! Xargs(args, substitute) " {{{
    norm gv"zy
    let l:result = system('xargs --delimiter "\n" ' . a:args, getreg('z'))
    let l:exit_status = v:shell_error

    if l:exit_status != 0
        echoerr l:result
        return
    endif

    if a:substitute
        let l:rbound = l:result[-1:] == "\n" ? -2 : -1
        execute 'normal' "gv\"=l:result[:" . l:rbound . "]\<CR>p"
    endif
endfunction " }}}

function! JumpOffsetExpr(offset) " {{{
    if a:offset == 1
        return 'j'
    elseif a:offset == -1
        return 'k'
    endif

    return "\<Esc>:call JumpOffset(" . a:offset . ")\<Cr>"
endfunction " }}}

function! JumpOffset(offset) " {{{
    let l:contextmark = getpos("''")
    normal! m'
    call setpos("''", l:contextmark)

    execute 'normal!' a:offset > 0 ? a:offset . 'j' : -a:offset . 'k'
endfunction "}}}

function! Aopen(line1, line2, current) " {{{
    silent execute '!aopen %' a:line1 . '-' . a:line2 a:current ? '-c' : ''
endfunction " }}}

function! Arel(filename) abort " {{{
    let l:output = system('arel ' . shellescape(a:filename))
    let l:exit_status = v:shell_error
    if l:exit_status != 0
        throw 'arel: ' . l:output
    endif
    return l:output[:-2]
endfunction " }}}

function! Tapi_FillQuickfixWindow(buffer, logfile) " {{{
    execute 'cgetfile' a:logfile
    call system('rm -f ' . a:logfile)
endfunction " }}}

function! Tapi_Chdir(buffer, pwd) " {{{
    execute 'lcd' a:pwd
endfunction " }}}

function! MapCarriageReturn() " {{{
    let l:curcol = col('.')
    let l:curoffset = l:curcol - 1
    let l:line = getline('.')
    let l:prevchar = l:line[l:curoffset - 1]
    let l:curchar = l:line[l:curoffset]
    let l:eol = l:curcol - 1 == strlen(l:line)
    let l:almosteol = l:curcol == strlen(l:line)
    if l:prevchar != '{' || !(l:eol || l:almosteol && l:curchar == '}')
        return "\<CR>"
    endif

    if match(l:line, '^\s*{}\?') >= 0
        let l:prevline = getline(line('.') - 1)
        let l:line = l:prevline . l:line
    endif

    let l:add_semicolon = 0
    if &filetype == 'cpp'
        let l:add_semicolon = CppShouldAddSemicolon(l:line)
    elseif &filetype == 'sql'
        let l:add_semicolon = SqlShouldAddSemicolon(l:line)
    endif

    let l:maybe_semicolon = ''
    let l:maybe_rbrace = l:curchar == '}' ? '' : '}'
    if l:add_semicolon
        let l:maybe_semicolon = '}' ? ';' : "\<C-O>a;"
    endif

    return "\<CR>" . l:maybe_rbrace . l:maybe_semicolon . "\<C-O>O"
endfunction " }}}

function! CppShouldAddSemicolon(line) " {{{
    let l:opt_ws = '\s*'
    let l:ws = '\s\+'
    let l:ident = '[a-zA-Z_][a-zA-Z0-9_]*'
    let l:opt_cv = '\(const\s\+\|volatile\s\+\)\?'

    let l:class_definition =        '^' . l:opt_ws . 'class'  . l:ws
    let l:struct_definition =       '^' . l:opt_ws . 'struct' . l:ws
    let l:variable_initialization =
        \ '^' . l:opt_ws . l:opt_cv . l:opt_cv
        \ . l:ident . l:ws . l:ident . l:opt_ws . '[={]'

    for l:pattern in [
        \ l:class_definition,
        \ l:struct_definition,
        \ l:variable_initialization,
        \ ]
        if match(a:line, l:pattern) >= 0
            return 1
        endif
    endfor
endfunction " }}}

function! SqlShouldAddSemicolon(line) " {{{
    return match(a:line, '^\s*\%(\$[a-zA-Z_][a-zA-Z0-9_]*\s*=\|return\s\+\)') >= 0
endfunction " }}}

function! Cbuffer(cmd, line1, line2) " {{{
    execute a:line1 . ',' . a:line2 . a:cmd
endfunction " }}}

function! Break() " {{{
    call term_sendkeys(winbufnr(1), "break " . expand("%:p") . ':' . line('.') . "\<Cr>")
endfunction " }}}

function! NerdTreeGetPaths() " {{{
    let l:curpath = expand('%:p')
    let l:root = expand('%:p:h')
    let l:maxlen = 0
    for l:path in g:olan_root_dirs
        let l:prefix = l:curpath[0:len(l:path) - 1]
        if l:prefix == l:path && l:maxlen < len(l:prefix)
            let l:root = l:path
            let l:maxlen = len(l:prefix)
        endif
    endfor
    return [l:root, l:curpath, l:maxlen != 0]
endfunction " }}}

function! NerdTreeFindExpr() " {{{
    call LoadPathAliases()

    if &bt != ''
        return "\<Cr>"
    endif

    let l:paths = NerdTreeGetPaths()
    let l:root = l:paths[0]
    let l:curpath = l:paths[1]
    return ":call NerdTreeFind('" . l:root .  "', '" . l:curpath . "')\<Cr>"
endfunction " }}}

function! NerdTreeFind(root, findpath) abort " {{{
    if !exists('t:NERDTreeBufName') || getbufvar(t:NERDTreeBufName, 'NERDTreeRoot', {'path': {'str': {->''} } }).path.str() !=# a:root
        execute 'NERDTree' a:root
    else
        NERDTreeFocus
    endif
    execute 'NERDTreeFind' a:findpath
endfunction " }}}

function! Only() " {{{
    if &filetype ==# 'nerdtree'
        only
        return
    endif
    let l:ntcurtab = g:NERDTree.ForCurrentTab()
    if type(l:ntcurtab) != type({}) || !l:ntcurtab.IsOpen()
        only
        return
    endif
    NERDTreeToggle
    only
    NERDTreeToggle
    wincmd p
endfunction " }}}

function! OpenTerminalFromNerdTree(shift) abort " {{{
    if &ft !=# 'nerdtree'
        return ":terminal\<Cr>"
    endif

    let l:curnode = g:NERDTreeFileNode.GetSelected()
    if l:curnode.path.isDirectory
        let l:termpath = l:curnode.path.str()
    else
        let l:termpath = fnamemodify(l:curnode.path.str(), ':h')
    endif

    let l:didsplit = SplitForNerdTree()
    if a:shift == 1 || l:didsplit
        let l:maybe_curwin = ' ++curwin'
    else
        let l:maybe_curwin = ''
    endif

    execute 'terminal ++close' . l:maybe_curwin . ' /bin/bash -c "cd ' . l:termpath . ' && exec ' . &shell . '"'
    execute 'lcd' l:termpath
    set nowinfixwidth
    doautocmd User OlanInitNtsync
endfunction " }}}

" Shamelessly stolen from NERDTree (s:Opener._newVSplit()) " {{{
function! SplitForNerdTree() abort
    if winnr('$') !=# 1
        wincmd p
        return 0
    endif

    let l:splitright = &splitright
    let l:eventignore = &eventignore

    let &splitright = g:NERDTreeWinPos ==# 'left'
    let &eventignore = 'all'

    vsplit
    let l:splitwinnr = winnr()
    call g:NERDTree.CursorToTreeWin()
    execute 'silent vertical resize ' . g:NERDTreeWinSize
    execute l:splitwinnr . 'wincmd w'

    let &eventignore=l:eventignore
    let &splitright=l:splitright
    return 1
endfunction " }}}

function! NerdTreeSync(isinit, event, match) " {{{
    if a:isinit
        let b:olan_ntsync =
            \ (&buftype ==# '' && bufname() !=# 'Result')
            \ || &buftype ==# 'terminal'
    endif

    if !exists('b:olan_ntsync') || !b:olan_ntsync
        return
    endif

    if exists('*popup_list')
        for l:winid in popup_list()
            if popup_getpos(l:winid).visible
                return
            endif
        endfor
    endif

    let l:ntcurtab = g:NERDTree.ForCurrentTab()
    if type(l:ntcurtab) != type({}) || !l:ntcurtab.IsOpen()
        return
    endif

    " TODO: ugly hack, but i don't know any other way to fix calling this from setloclist()
    try
        NERDTreeFocus
        wincmd p
    catch /.*/
        return
    endtry

    let l:curroot = l:ntcurtab.root.path.str()

    if &bt ==# 'terminal' || len(bufname()) == 0
        let l:curpath = getcwd()
    else
        let l:curpath = expand('%:p')
    endif

    if l:curpath =~# '^fugitive://'
        return
    endif

    if !isdirectory(l:curpath) && !filereadable(l:curpath)
        let l:parentpath = fnamemodify(l:curpath, ':p:h')
        if l:parentpath == l:curroot
            NERDTreeFocus
            call l:ntcurtab.root.putCursorHere(0, 0)
        else
            let l:parentdir = g:NERDTreePath.New(l:parentpath)
            let l:node = l:ntcurtab.root.reveal(l:parentdir)
            NERDTreeFocus
            call l:node.putCursorHere(0, 0)
        endif
        wincmd p
        return
    endif

    NERDTreeFocus
    if l:curpath == l:curroot
        norm P
    elseif l:curpath[0:len(l:curroot) - 1] !=# l:curroot
        norm Pk
    else
        let l:prevnode = g:NERDTreeFileNode.GetSelected()
        let l:pathobj = g:NERDTreePath.New(l:curpath)
        let l:node = l:ntcurtab.root.reveal(l:pathobj)

        mark '
        let l:line_before = line('.')
        call l:node.putCursorHere(0, 0)
        let l:line_after = line('.')

        let l:text = substitute(getline('.'), '^[ ]\+', '', '')
        let l:rendered_node_text = l:node.displayString()
        if l:text != l:rendered_node_text || (l:line_before == l:line_after && l:prevnode.path.str() !=# l:node.path.str())
            call l:ntcurtab.render()
            call l:node.putCursorHere(0, 0)
        endif
        setlocal cursorline " Ghost cursorline workaround
    endif
    wincmd p
endfunction " }}}

function! Align(where) " {{{
    if type(g:NERDTree.ForCurrentTab()) == type(0) || !g:NERDTree.ForCurrentTab().IsOpen()
        execute "normal! \<C-w>" . a:where
        return
    endif

    NERDTreeToggle
    execute "normal! \<C-w>" . a:where
    NERDTreeToggle
    execute "normal! \<C-w>p"
endfunction " }}}

function! ProjectDir() " {{{
    if type(g:NERDTree.ForCurrentTab()) == type(0) || !g:NERDTree.ForCurrentTab().IsOpen()
        return '.'
    else
        return g:NERDTree.ForCurrentTab().root.path.str()
    endif
endfunction " }}}

function! GrepExpr(ctrl) " {{{
    return ":call Grep('', " . a:ctrl . ")\<C-Left>\<Left>\<Left>\<Left>"
endfunction " }}}

function! Grep(pattern, icase) " {{{
    let l:nerdtree = &ft ==# 'nerdtree'
    let l:didsplit = 0
    if l:nerdtree
        let l:didsplit = SplitForNerdTree()
    endif
    if l:didsplit && &ft ==# 'nerdtree'
        let l:winid = win_getid()
        wincmd n
        call win_gotoid(l:winid)
        wincmd q
    endif

    let l:maybe_icase = a:icase ? 'i' : ''
    silent execute 'grep -rI' . l:maybe_icase . ' "' . escape(a:pattern, '"\#') . '" ' . shellescape(ProjectDir())
    if l:didsplit && len(getqflist()) == 0
        wincmd q
        wincmd q
        echom 'Nothing found for pattern ' . a:pattern
        return
    endif
    redraw!
endfunction " }}}

function! DropTab() " {{{
    for l:i in range(winnr('$'))
        execute 'bd!' winbufnr(1)
    endfor
endfunction " }}}

function! JsonFormat() "{{{
    echom 'JSONFORMAT!'
    normal! gv"zy
    let l:output = system('python3 -mjson.tool', getreg('z'))
    if v:shell_error != 0
        echoerr l:output
        return
    endif
    call setreg('z', l:output[:-2])

    execute "normal! gvc\<C-r>z\<Esc>"
endfunction " }}}

function! ReloadQuickFix() " {{{
    if exists('g:ycmref') || QuickFixBufNr() != bufnr()
        return
    endif

    let l:eventignore = &eventignore
    set eventignore=all
    execute 'lcd' ProjectDir()
    call setqflist(getqflist())
    let &eventignore = l:eventignore
endfunction " }}}

function! GoToReferences() " {{{
    let g:ycmref = 1
    YcmCompleter GoToReferences

    execute 'lcd' ProjectDir()
    call setqflist(getqflist())
    unlet g:ycmref
endfunction " }}}

function! Diags() " {{{
    let g:ycmref = 1
    YcmDiags 
    unlet g:ycmref
endfunction " }}}

function! RefactorRename(name) " {{{
    let g:ycmref = 1
    exec 'YcmCompleter RefactorRename' a:name
    unlet g:ycmref
endfunction " }}}

function! GoTo() " {{{
    let g:ycmref = 1
    exec 'YcmCompleter GoTo'
    unlet g:ycmref
endfunction
" }}}

function! GoToImplementation() " {{{
    let g:ycmref = 1
    YcmCompleter GoToImplementation
    unlet g:ycmref
endfunction
" }}}

function! QuickFixBufNr() " {{{
    return getqflist({'qfbufnr': 1})['qfbufnr']
endfunction
" }}}

function! CtrlSpace() abort " {{{
    if &ft ==# 'sql'
        DBExecSQLUnderCursor
    endif
endfunction " }}}

function! Include() abort " {{{
    if &ft == 'go'
        let l:packageline = getline(1)
        let l:m = matchlist(l:packageline, 'package \(.*\)')
        if len(l:m) == 0
            echoerr 'Invalid package line: ' . l:packageline
            return
        endif
        let l:package = l:m[1]

        let l:arel = system('arel ' . shellescape(expand('%')))
        let l:arelbase = fnamemodify(l:arel, ':h:h')

        call Yank("\t\"a.yandex-team.ru/" . l:arelbase . '/' .  l:package . "\"\n")
        return
    endif

    call Yank("!printf '\\#include <\\%s>\n\n' `arel %`")
endfunction " }}}

function! ToggleTermwinsize() abort " {{{
    if len(&tws) == 0
        set termwinsize=0*5000
    else
        set termwinsize=
    endif
endfunction " }}}

function! CurrentSyntaxGroup() abort
    let l:stack = synstack(line('.'), col('.'))
    if len(l:stack) == 0
        return -1
    endif
    return l:stack[-1]
endfunction

function! Skip() abort
    let l:stack = synstack(line('.'), col('.'))
    if len(l:stack) == 0
        return 0
    endif
    let l:last = l:stack[-1]
    return
        \ l:last == 693
        \ || l:last == 284
        \ || l:last == 253
        \ || l:last == 174
        \ || l:last == 166
endfunction

function! Up() abort
    if &ft !~# 'go\|json\|cpp'
        normal! [{
        return
    endif

    let l:contextmark = getpos("''")
    normal! m'
    call setpos("''", l:contextmark)

    let l:result = searchpair('[[{(]', '', '[]})]', 'b', funcref('Skip'), 1)
    "let l:result = searchpair('[[{(]', '', '[]})]', 'b', '', 1)
    if result <= 0
        execute "normal! \<C-O>"
    endif
endfunction

function! Break() abort
    Arel
    call setreg('"', 'break ' . getreg('"') . ':' . line('.'))
endfunction

" ############################################################################## }}}
" ################################  Vundle stuff  ############################## {{{
" ##############################################################################

filetype off
call vundle#begin()
Plugin 'VundleVim/Vundle.vim'

Plugin 'jiangmiao/auto-pairs'
Plugin 'endel/vim-github-colorscheme'
Plugin 'google/vim-searchindex'
Plugin 'tpope/vim-repeat'
Plugin 'tpope/vim-surround'
Plugin 'vim-scripts/BufOnly.vim'
Plugin 'preservim/nerdtree'
Plugin 'udalov/kotlin-vim'

if exists('g:devmode') && g:devmode
    " C/C++ stuff
    Plugin 'vim-scripts/Cpp11-Syntax-Support'   " Proper C++11 syntax highlighting
    Plugin 'Valloric/YouCompleteMe'
    Plugin 'mom0tomo/dotfiles'
    Plugin 'vim-scripts/git-time-lapse'
    Plugin 'vim-scripts/a.vim'                  " Quick switching between .h/.cpp
    Plugin 'tpope/vim-fugitive'
    Plugin 'ovandriyanov/dlvim'
    Plugin 'vim-scripts/dbext.vim'
    Plugin 'vim-signify', {'pinned': 1}
    Plugin 'vim-quarc', {'pinned': 1}
endif

call vundle#end()
filetype plugin indent on

colorscheme github

" ############################################################################## }}}
" ############################  Extra configuration  ########################### {{{
" ##############################################################################

let s:extra_conf_file = expand('~/.vim/extra.vim')
if filereadable(s:extra_conf_file)
    exe "source " . s:extra_conf_file
endif

" ############################################################################## }}}
